:fr:
== The Visitor pattern

ifdef::slides[:leveloffset: -1]

image::les-visiteurs.jpg[]

=== The problem

Here are some examples:

[%step]
- A *structure* of objects contains many different classes with separate interfaces, and you want to perform operations on these objects who depend on their concrete classes.
- It involves performing several separate operations with no relation between
them, on the objects of a structure, and this by *avoiding polluting their classes* with these operations.
- The classes that define the object structure rarely change, but we must
often *define new operations* on this structure.

=== Illustration

Adapted from an example taken here: http://www.tutorialspoint.com/design_pattern/visitor_pattern.htm

ifndef::slides[.A classical structure (without pattern)]
image::visitor1.svg[width=100%]

ifdef::slides[:leveloffset: -1]

==== Step 1
:uk:

ifdef::uk[Define an interface to represent element.]
ifdef::fr[Définir une interface pour représenter les éléments de la structure.]

ifndef::slides[.Implementation of a hierarchy]
image::visitor2.svg[width=100%]

ifdef::slides[==== Step 1 (suite)]

ifndef::slides[.Use of an interface]
image::visitor3.svg[width=100%]

ifndef::slides[.ComputerPart.java (extrait)]
[source,java]
-----
public interface ComputerPart {
   ...
}
-----

==== Step 2

Anticipate the use of Visitor.

ifndef::slides[.ComputerPartVisitor.java (extrait)]
[source,java]
-----
public interface ComputerPartVisitor {
	...
}
-----

ifndef::slides[.ComputerPart.java]
[source,java]
-----
public interface ComputerPart {
   public void accept(ComputerPartVisitor computerPartVisitor);
}
-----

==== Step 3

ifdef::uk[Create concrete classes extending the above class.]
ifdef::fr[Créer les classes concrètes qui implémentent l'interface.]

ifndef::slides[.Keyboard.java]
[source,java]
-----
public class Keyboard implements ComputerPart {

   @Override
   public void accept(ComputerPartVisitor computerPartVisitor) {
      computerPartVisitor.visit(this);
   }
}
-----

...

ifdef::slides[==== Step 3 (suite)]

ifndef::slides[.Computer.java]
[source,java]
-----
public class Computer implements ComputerPart {

   ComputerPart[] parts;

   public Computer(){
      parts = new ComputerPart[] {new Mouse(), new Keyboard(), new Monitor()};
   }


   @Override
   public void accept(ComputerPartVisitor computerPartVisitor) {
      for (int i = 0; i < parts.length; i++) {
         parts[i].accept(computerPartVisitor);
      }
      computerPartVisitor.visit(this);
   }
}
-----

==== Step 4

ifdef::uk[Define an interface to represent visitor.]
ifdef::fr[Définir l'interface pour représenter le Visitor.]

ifndef::slides[.ComputerPartVisitor.java]
[source,java]
-----
public interface ComputerPartVisitor {
	public void visit(Computer computer);
	public void visit(Mouse mouse);
	public void visit(Keyboard keyboard);
	public void visit(Monitor monitor);
}
-----

==== Step 5

ifdef::uk[Create concrete visitor implementing the above class.]
ifdef::fr[Créer des Visitors concrets.]

ifndef::slides[.Visitor : l'interface]
image::visitor4.svg[width=100%]

ifdef::slides[==== Step 5 (suite)]

ifndef::slides[.DisplayVisitor.java]
[source,java]
-----
public class DisplayVisitor implements ComputerPartVisitor {

   @Override
   public void visit(Computer computer) {
      System.out.println("Displaying Computer.");
   }

   @Override
   public void visit(Mouse mouse) {
      System.out.println("Displaying Mouse.");
   }

   @Override
   public void visit(Keyboard keyboard) {
      System.out.println("Displaying Keyboard.");
   }

   @Override
   public void visit(Monitor monitor) {
      System.out.println("Displaying Monitor.");
   }
}
-----

==== Step 6

ifdef::uk[Use the `DisplayVisitor` to display parts of Computer.]
ifdef::fr[Utiliser le Visitor `DisplayVisitor`.]

ifndef::slides[.VisitorPatternDemo.java]
[source,java]
-----
public class VisitorPatternDemo {
   public static void main(String[] args) {

      ComputerPart computer = new Computer();
      computer.accept(new DisplayVisitor());
   }
}
-----

==== Step 7 (final)

Verify the output.

[source]
-----
Displaying Mouse.
Displaying Keyboard.
Displaying Monitor.
Displaying Computer.
-----

ifdef::slides[:leveloffset: +1]

=== The Visitor pattern

*Visitor* allows the representation of an operation that is applicable
to different elements of an object structure.

It defines a new operation, *without modifying the class*!.

ifdef::slides[=== The Visitor pattern (structure)]

ifndef::slides[.Patron Visitor : structure]
image::visitor-dc.svg[width=100%]

ifdef::slides[=== The Visitor pattern (behavior)]

ifndef::slides[.Patron Visitor : behavior]
image::visitor-seq.png[width=100%]

ifdef::slides[=== The Visitor pattern (Google)]

ifndef::slides[.Visitor on Google]
image::visitor-google.png[width=100%]


=== Avantages/Drawbacks

Avantages :

[%step]
- Allows you to add operations to the structure of a Composite *without modifying the structure itself*.
- Adding new operations is relatively easy.
- The code of operations performed by the Visitor is *centralized*.

Drawbacks :

[%step]
- The encapsulation principle of the Composite classes is broken.
- As a navigation fonctionis implied, all modifications on the structure of Composite is more complicated.

=== Examples

- calcul sur un ensemble structuré d'éléments
- génération de rapports ou de code
- ...

=== Example in Java

NOTE: Example taken form http://www.journaldev.com/1769/visitor-design-pattern-in-java-example-tutorial[here].

ifndef::slides[.ItemElement.java]
[source,java]
----------
public interface ItemElement {

  public int accept(ShoppingCartVisitor visitor);
}
----------

ifdef::slides[=== Example (suite)]

ifndef::slides[.Book.java]
[source,java]
----------
public class Book implements ItemElement {

  private int price;
  private String isbnNumber;

  public Book(int cost, String isbn){
    this.price=cost;
    this.isbnNumber=isbn;
  }

  public int getPrice() {
    return price;
  }

  public String getIsbnNumber() {
    return isbnNumber;
  }

  @Override
  public int accept(ShoppingCartVisitor visitor) {
    return visitor.visit(this);
  }

}
----------

ifdef::slides[=== Example (suite)]

ifndef::slides[.Fruit.java]
[source,java]
----------
public class Fruit implements ItemElement {

  private int pricePerKg;
  private int weight;
  private String name;

  public Fruit(int priceKg, int wt, String nm){
    this.pricePerKg=priceKg;
    this.weight=wt;
    this.name = nm;
  }

  public int getPricePerKg() {
    return pricePerKg;
  }

  public int getWeight() {
    return weight;
  }

  public String getName(){
    return this.name;
  }

  @Override
  public int accept(ShoppingCartVisitor visitor) {
    return visitor.visit(this);
  }
}
----------

ifdef::slides[=== Example (suite)]

ifndef::slides[.ShoppingCartVisitor.java]
[source,java]
----------
public interface ShoppingCartVisitor {

  int visit(Book book);
  int visit(Fruit fruit);
}
----------

ifdef::slides[=== Example (suite)]

ifndef::slides[.ShoppingCartVisitorImpl.java]
[source,java]
----------
public class ShoppingCartVisitorImpl implements ShoppingCartVisitor {

  @Override
  public int visit(Book book) {
    int cost=0;
    //apply 5$ discount if book price is greater than 50
    if(book.getPrice() > 50){
      cost = book.getPrice()-5;
    } else cost = book.getPrice();
    System.out.println("Book ISBN::"+book.getIsbnNumber() + " cost ="+cost);
    return cost;
  }

  @Override
  public int visit(Fruit fruit) {
    int cost = fruit.getPricePerKg()*fruit.getWeight();
    System.out.println(fruit.getName() + " cost = "+cost);
    return cost;
  }
}
----------

ifdef::slides[=== Example (suite)]

ifndef::slides[.ShoppingCartClient.java]
[source,java]
----------
public class ShoppingCartClient {

  public static void main(String[] args) {
    ItemElement[] items = new ItemElement[]{new Book(20, "1234"),new Book(100, "5678"),
    new Fruit(10, 2, "Banana"), new Fruit(5, 5, "Apple")};

    int total = calculatePrice(items);
    System.out.println("Total Cost = "+total);
  }

  private static int calculatePrice(ItemElement[] items) {
    ShoppingCartVisitor visitor = new ShoppingCartVisitorImpl();
    int sum=0;
    for(ItemElement item : items){
      sum = sum + item.accept(visitor);
    }
    return sum;
  }

}
----------

ifdef::slides[=== Example (suite)]

..........
Book ISBN::1234 cost =20
Book ISBN::5678 cost =95
Banana cost = 20
Apple cost = 25
Total Cost = 160
..........

ifdef::slides[:leveloffset: +1]
